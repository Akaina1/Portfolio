<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 42de5919-97cf-4911-995a-cd203577c9d2 (2024-12-23 20:20Z) -->

# Implementing an Achievement System with Zustand (2024-12-23 20:20Z)

_**User**_

I have created a component with a small hidden puzzle inside it. I would like to extend my entire website to have an achievement system that allows users to find secrets and get a small reward badge and title.

I have added zustand to create a global store to manage the user achievements.

we will need to store achievement data in localstorage for users and make sure they persist.

I have created the folder src/stores to hold my zustand logic

I should be able to call an "AchievementUnlocked" function with a unique id to unlock specific achievements for different actions around my website.

I want it to be easy to integrate new puzzles into the achievement system

---

_**Agent**_

I'll help you create an achievement system using Zustand. First, let's create the achievement store and types.

```typescript:src/stores/types/achievements.ts
export type Achievement = {
  id: string;
  title: string;
  description: string;
  icon?: string;
  unlockedAt?: string;
  secret?: boolean;
};

export type AchievementStore = {
  achievements: Record<string, Achievement>;
  unlockedAchievements: Set<string>;
  unlockAchievement: (id: string) => void;
  hasAchievement: (id: string) => boolean;
  initializeFromStorage: () => void;
};
```

Now let's create the achievement store:

```typescript:src/stores/useAchievementStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Achievement, AchievementStore } from './types/achievements';

// Define your achievements here
const ACHIEVEMENTS: Record<string, Achievement> = {
  'secret-code-1': {
    id: 'secret-code-1',
    title: 'Code Breaker',
    description: 'Found your first secret code',
    secret: true,
  },
  // Add more achievements as needed
};

export const useAchievementStore = create<AchievementStore>()(
  persist(
    (set, get) => ({
      achievements: ACHIEVEMENTS,
      unlockedAchievements: new Set<string>(),

      unlockAchievement: (id: string) => {
        const { unlockedAchievements, achievements } = get();
        
        // Check if achievement exists and isn't already unlocked
        if (!achievements[id] || unlockedAchievements.has(id)) {
          return;
        }

        const newUnlocked = new Set(unlockedAchievements);
        newUnlocked.add(id);
        
        set({
          unlockedAchievements: newUnlocked,
        });

        // Show achievement notification
        // You can implement this later with a toast or custom UI
        console.log(`Achievement Unlocked: ${achievements[id].title}`);
      },

      hasAchievement: (id: string) => {
        return get().unlockedAchievements.has(id);
      },

      initializeFromStorage: () => {
        // This is handled by the persist middleware
      },
    }),
    {
      name: 'achievements-storage',
      // Custom serialization to handle Set
      serialize: (state) => JSON.stringify({
        ...state,
        unlockedAchievements: Array.from(state.unlockedAchievements),
      }),
      // Custom deserialization to restore Set
      deserialize: (str) => {
        const parsed = JSON.parse(str);
        return {
          ...parsed,
          unlockedAchievements: new Set(parsed.unlockedAchievements),
        };
      },
    }
  )
);
```

Now let's modify your HomeHero component to use the achievement system:

```typescript:src/blocks/HomeHero/Component.tsx
// ... existing imports ...
import { useAchievementStore } from '@/stores/useAchievementStore';

// ... existing code ...

const handleCharacterClick = (char: string) => {
  setShowError(false);

  if (char === '?') {
    if (!puzzleState.sequence) return;

    const matchingSecret = secretCodes.find(
      (code) => code.code.toLowerCase() === puzzleState.sequence.toLowerCase()
    );

    if (matchingSecret) {
      // Unlock achievement when secret is found
      useAchievementStore.getState().unlockAchievement('secret-code-1');
      
      setPuzzleState((prev) => ({
        ...prev,
        isSubmitted: true,
        activeSecret: matchingSecret,
      }));
    } else {
      setShowError(true);
      setTimeout(() => {
        setPuzzleState({
          sequence: '',
          isSubmitted: false,
          activeSecret: null,
        });
        setShowError(false);
      }, 2000);
    }
    return;
  }

  // ... rest of the function
};

// ... rest of the component
```

This setup provides:
1. A persistent achievement system using localStorage
2. Type-safe achievement definitions
3. Easy achievement unlocking with `unlockAchievement(id)`
4. Achievement status checking with `hasAchievement(id)`
5. Support for secret achievements
6. Easy extensibility for adding new achievements

To add new puzzles/achievements:
1. Add new achievement definitions to the `ACHIEVEMENTS` object
2. Call `unlockAchievement(id)` when the condition is met

You can later add a UI component to display unlocked achievements and an achievement notification system using a toast library or custom UI.

---

_**User**_

Object literal may only specify known properties, and 'serialize' does not exist in type 'PersistOptions<AchievementStore, AchievementStore>'.ts(2353)

---

_**Agent**_

Ah, I see the issue. In the newer versions of Zustand, the persist middleware's type definitions are more strict. Let's fix the typing by using the correct property name `storage`:

```typescript:src/stores/useAchievementStore.ts
// ... existing code ...

export const useAchievementStore = create<AchievementStore>()(
  persist(
    (set, get) => ({
      achievements: ACHIEVEMENTS,
      unlockedAchievements: new Set<string>(),
      // ... other state and methods
    }),
    {
      name: 'achievements-storage',
      storage: {
        getItem: (name) => {
          const str = localStorage.getItem(name);
          if (!str) return null;
          const parsed = JSON.parse(str);
          return {
            ...parsed,
            state: {
              ...parsed.state,
              unlockedAchievements: new Set(parsed.state.unlockedAchievements),
            },
          };
        },
        setItem: (name, value) => {
          const serialized = {
            ...value,
            state: {
              ...value.state,
              unlockedAchievements: Array.from(value.state.unlockedAchievements),
            },
          };
          localStorage.setItem(name, JSON.stringify(serialized));
        },
        removeItem: (name) => localStorage.removeItem(name),
      },
    }
  )
);
```

The change here is that instead of using `serialize` and `deserialize`, we're using the `storage` property to provide a custom storage implementation that handles the Set serialization/deserialization. This follows the correct typing for `PersistOptions` in Zustand.

This will fix the TypeScript error while maintaining the same functionality of properly storing and retrieving the Set of unlocked achievements.

---

_**User**_

Let's modify the secretCodes data so that it has an optional achievementCode field that can be used to unlockAchievement

---

_**Agent**_

I'll help you modify the `SecretData` type and `secretCodes` array to include achievement integration.

```typescript:src/blocks/HomeHero/secrets.ts
export type SecretData = {
  code: string;
  title: string;
  content: string;
  achievementId?: string; // Optional achievement ID to unlock
};

export const secretCodes: SecretData[] = [
  {
    code: 'HELLO',
    title: 'Hello Secret',
    content: 'You found the first secret!',
    achievementId: 'secret-hello',
  },
  {
    code: 'DEV',
    title: 'Developer Mode',
    content: "You've unlocked developer insights.",
    achievementId: 'secret-dev-mode',
  },
  {
    code: 'PUZZLE',
    title: 'Puzzle Master',
    content: "You're getting good at this!",
    achievementId: 'secret-puzzle-master',
  },
];
```

Now you'll need to update your `handleCharacterClick` function in the HomeHero component to check for and unlock achievements:

```typescript:src/blocks/HomeHero/Component.tsx
// ... existing imports ...
import { useAchievementStore } from '@/stores/useAchievementStore';

// ... existing code ...

const handleCharacterClick = (char: string) => {
  setShowError(false);

  if (char === '?') {
    if (!puzzleState.sequence) return;

    const matchingSecret = secretCodes.find(
      (code) => code.code.toLowerCase() === puzzleState.sequence.toLowerCase()
    );

    if (matchingSecret) {
      // Unlock achievement if one is specified
      if (matchingSecret.achievementId) {
        useAchievementStore.getState().unlockAchievement(matchingSecret.achievementId);
      }
      
      setPuzzleState((prev) => ({
        ...prev,
        isSubmitted: true,
        activeSecret: matchingSecret,
      }));
    } else {
      setShowError(true);
      setTimeout(() => {
        setPuzzleState({
          sequence: '',
          isSubmitted: false,
          activeSecret: null,
        });
        setShowError(false);
      }, 2000);
    }
    return;
  }

  // ... rest of the function
};
```

This approach:
1. Makes achievements optional for each secret code
2. Keeps the achievement IDs with their related secrets
3. Automatically unlocks achievements when secrets are found
4. Maintains backward compatibility with any existing code that doesn't use achievements

Remember to add corresponding achievement definitions in your achievement store for each `achievementId` you specify in the secrets.

---

_**User**_

let's add achievements for each of these codes

---

_**Agent**_

I'll add the corresponding achievements to the `ACHIEVEMENTS` object in your achievement store:

```typescript:src/stores/useAchievementStore.ts
// ... existing imports ...

const ACHIEVEMENTS: Record<string, Achievement> = {
  'secret-hello': {
    id: 'secret-hello',
    title: 'First Steps',
    description: 'Found your first hidden secret code',
    secret: true,
  },
  'secret-dev-mode': {
    id: 'secret-dev-mode',
    title: 'Developer Insight',
    description: 'Discovered the hidden developer mode',
    secret: true,
  },
  'secret-puzzle-master': {
    id: 'secret-puzzle-master',
    title: 'Puzzle Master',
    description: 'You have a knack for finding hidden things',
    secret: true,
  },
  // ... any existing achievements ...
};

// ... rest of the file
```

Each achievement:
- Has a unique `id` that matches the `achievementId` in the secrets
- Is marked as `secret: true` since they're hidden puzzle rewards
- Has a descriptive title and description that will be shown when unlocked
- Follows a consistent naming pattern (`secret-*`) for organization

You can now unlock these achievements by entering the corresponding secret codes:
- "HELLO" unlocks 'First Steps'
- "DEV" unlocks 'Developer Insight'
- "PUZZLE" unlocks 'Puzzle Master'

---

_**User**_

can we extend the puzzle component we created to alter the renderInteractiveText.

Currently the mainText being fed to make the interactive text buttons does not have every letter of the alphabet.

I want to add another secret code 'moreletters' that when submitted will append the following to the mainText that is being used in renderInteractiveText:

"Quick examples include fixing bugs, jumping hurdles, or crafting zesty, unique experiences."

This will make it so the user has all available letters to type even more codes.

---

_**Agent**_



I'll help you modify the component to support dynamic text expansion. First, let's add the new secret code:

```typescript:src/blocks/HomeHero/secrets.ts
export const secretCodes: SecretData[] = [
  // ... existing codes ...
  {
    code: 'MORELETTERS',
    title: 'Alphabet Unlocked',
    content: 'You now have access to more letters!',
    achievementId: 'secret-alphabet',
  },
];
```

Now let's modify the HomeHero component to handle the expandable text:

```typescript:src/blocks/HomeHero/Component.tsx
// ... existing imports ...

export const HomeHeroBlock: React.FC<HomeHeroProps> = ({
  mainText,
  dynamicText,
  links,
}) => {
  // ... existing state ...
  const [expandedText, setExpandedText] = useState('');
  
  const handleCharacterClick = (char: string) => {
    setShowError(false);

    if (char === '?') {
      if (!puzzleState.sequence) return;

      const matchingSecret = secretCodes.find(
        (code) => code.code.toLowerCase() === puzzleState.sequence.toLowerCase()
      );

      if (matchingSecret) {
        // Handle the MORELETTERS code
        if (puzzleState.sequence.toLowerCase() === 'moreletters') {
          setExpandedText(
            ' Quick examples include fixing bugs, jumping hurdles, or crafting zesty, unique experiences.'
          );
        }

        if (matchingSecret.achievementId) {
          useAchievementStore.getState().unlockAchievement(matchingSecret.achievementId);
        }

        setPuzzleState((prev) => ({
          ...prev,
          isSubmitted: true,
          activeSecret: matchingSecret,
        }));
      } else {
        // ... existing error handling ...
      }
      return;
    }

    // ... rest of the function
  };

  const renderInteractiveText = () => {
    const fullText = `${mainText}${expandedText}`;
    
    return fullText.split('').map((char, index) => (
      <span
        key={`${char}-${index}`}
        onClick={() => handleCharacterClick(char)}
        className={cn(
          'cursor-pointer transition-colors duration-200',
          char === '?' ? 'hover:text-red-500' : 'hover:text-blue-300',
          // Add a special highlight for the expanded text
          index >= mainText.length && 'text-emerald-500 dark:text-emerald-400'
        )}
        role="button"
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            handleCharacterClick(char);
          }
        }}
      >
        {char}
      </span>
    ));
  };

  // ... rest of the component
};
```

And let's add the corresponding achievement:

```typescript:src/stores/useAchievementStore.ts
const ACHIEVEMENTS: Record<string, Achievement> = {
  // ... existing achievements ...
  'secret-alphabet': {
    id: 'secret-alphabet',
    title: 'Letter Collector',
    description: 'Unlocked additional letters to create new combinations',
    secret: true,
  },
};
```

This implementation:
1. Adds a new state variable `expandedText` to store the additional text
2. Modifies `renderInteractiveText` to include both the original and expanded text
3. Adds visual distinction to the expanded text with a green color
4. Creates a new achievement for unlocking more letters
5. Preserves all existing functionality while adding the new feature

When users enter the code "MORELETTERS", they'll:
1. See the new text appear with a distinct color
2. Unlock the "Letter Collector" achievement
3. Have access to more letters for other secret codes

The expanded text provides access to letters like 'q', 'j', 'z', and others that might not have been available in the original text, enabling more complex secret codes.

---

_**User**_

I want to add more functionality to the secret codes and the HomeHero component.

I want to make the content field optional and add another optional media field.

In this field I should be able to pass a url to a media item (either image or gif)

---

_**Agent**_

I'll help you modify the SecretData type and update the component to handle optional media content.

First, let's update the SecretData type:

```typescript:src/blocks/HomeHero/secrets.ts
export type SecretData = {
  code: string;
  title: string;
  content?: string; // Now optional
  achievementId?: string;
  media?: {
    url: string;
    type: 'image' | 'gif';
    alt?: string;
  };
};

export const secretCodes: SecretData[] = [
  {
    code: 'HELLO',
    title: 'Hello Secret',
    content: 'You found the first secret!',
    achievementId: 'secret-hello',
  },
  {
    code: 'DEV',
    title: 'Developer Mode',
    content: "You've unlocked developer insights.",
    achievementId: 'secret-dev-mode',
    media: {
      url: '/images/dev-mode.gif',
      type: 'gif',
      alt: 'Developer mode activated',
    },
  },
  // ... other existing codes ...
];
```

Now let's update the secret content display in the HomeHero component:

```typescript:src/blocks/HomeHero/Component.tsx
// ... existing imports ...

const SecretContent: React.FC<{ secret: SecretData }> = ({ secret }) => {
  return (
    <div
      className={cn(
        'rounded-lg bg-black/10 p-6 dark:bg-white/10',
        'duration-300 animate-in fade-in slide-in-from-bottom-4'
      )}
    >
      <h2 className="mb-4 text-center text-xl font-bold text-black dark:text-white">
        {secret.title}
      </h2>
      
      {/* Media Display */}
      {secret.media && (
        <div className="mb-4 flex justify-center">
          {secret.media.type === 'gif' ? (
            <img
              src={secret.media.url}
              alt={secret.media.alt || secret.title}
              className="max-h-[200px] rounded-lg object-contain"
            />
          ) : (
            <img
              src={secret.media.url}
              alt={secret.media.alt || secret.title}
              className="max-h-[300px] rounded-lg object-cover"
              loading="lazy"
            />
          )}
        </div>
      )}
      
      {/* Content Text */}
      {secret.content && (
        <p className="text-center text-gray-700 dark:text-gray-300">
          {secret.content}
        </p>
      )}
    </div>
  );
};

export const HomeHeroBlock: React.FC<HomeHeroProps> = ({
  mainText,
  dynamicText,
  links,
}) => {
  // ... existing code ...

  return (
    <div className="animate-pull-down container relative z-0 -mt-1 flex h-full flex-col items-center justify-center rounded-b-xl bg-black/5 p-4 pt-8 shadow-lg shadow-black/35 lg:pt-28 dark:bg-white/5">
      {/* ... existing JSX ... */}

      {/* Secret Content Area */}
      <div className="mt-4 w-full max-w-2xl">
        {/* ... sequence display and error message ... */}

        {/* Secret Content */}
        {puzzleState.activeSecret && (
          <SecretContent secret={puzzleState.activeSecret} />
        )}
      </div>
    </div>
  );
};
```

Now you can add media to your secret codes like this:

```typescript:src/blocks/HomeHero/secrets.ts
export const secretCodes: SecretData[] = [
  // ... existing codes ...
  {
    code: 'MORELETTERS',
    title: 'Alphabet Unlocked',
    content: 'You now have access to more letters!',
    achievementId: 'secret-alphabet',
    media: {
      url: '/images/alphabet.gif',
      type: 'gif',
      alt: 'Alphabet animation',
    },
  },
  {
    code: 'CATMODE',
    title: 'Cat Mode Activated',
    achievementId: 'secret-cat-mode',
    media: {
      url: '/images/cat.gif',
      type: 'gif',
      alt: 'A cute cat gif',
    },
  },
  // Example with just an image
  {
    code: 'LANDSCAPE',
    title: 'Beautiful Vista',
    achievementId: 'secret-vista',
    media: {
      url: '/images/landscape.jpg',
      type: 'image',
      alt: 'A beautiful landscape',
    },
  },
];
```

This implementation:
1. Makes the content field optional
2. Adds support for both images and GIFs
3. Includes proper alt text support for accessibility
4. Handles different image types with appropriate styling
5. Uses lazy loading for images (not GIFs) to improve performance
6. Maintains all existing functionality while adding the new features

The media will be displayed above any content text if both are present, and the component will work correctly with any combination of content and media (both, either, or neither).

---

_**User**_

I want this to work with giphy.com links which are formatted like this for embedding them:

<div style="width:100%;height:0;padding-bottom:132%;position:relative;"><iframe src="https://giphy.com/embed/GVtvJRr3sJDbkNdumY" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/helloangelgirl-uwu-glamoworm-kawaii-GVtvJRr3sJDbkNdumY">via GIPHY</a></p>

---

_**Agent**_



I'll help you modify the SecretData type and component to handle Giphy embeds. First, let's update the types to support Giphy:

```typescript:src/blocks/HomeHero/secrets.ts
export type MediaData = {
  type: 'image' | 'gif' | 'giphy';
  url: string;
  alt?: string;
  giphyId?: string; // For Giphy embeds
};

export type SecretData = {
  code: string;
  title: string;
  content?: string;
  achievementId?: string;
  media?: MediaData;
};

export const secretCodes: SecretData[] = [
  // ... other codes ...
  {
    code: 'UWU',
    title: 'UwU Mode',
    media: {
      type: 'giphy',
      giphyId: 'GVtvJRr3sJDbkNdumY',
      alt: 'UwU kawaii animation',
    },
    achievementId: 'secret-uwu',
  },
];
```

Now let's create a separate component for media rendering and update the SecretContent component:

```typescript:src/blocks/HomeHero/Component.tsx
const SecretMedia: React.FC<{ media: MediaData }> = ({ media }) => {
  if (media.type === 'giphy' && media.giphyId) {
    return (
      <div className="relative w-full pt-[56.25%]">
        <iframe
          src={`https://giphy.com/embed/${media.giphyId}`}
          className="absolute inset-0 h-full w-full rounded-lg"
          frameBorder="0"
          allowFullScreen
          title={media.alt || 'Giphy embed'}
        />
      </div>
    );
  }

  if (media.type === 'gif' || media.type === 'image') {
    return (
      <img
        src={media.url}
        alt={media.alt || 'Secret content media'}
        className={cn(
          'rounded-lg',
          media.type === 'gif' 
            ? 'max-h-[200px] object-contain' 
            : 'max-h-[300px] object-cover'
        )}
        loading="lazy"
      />
    );
  }

  return null;
};

const SecretContent: React.FC<{ secret: SecretData }> = ({ secret }) => {
  return (
    <div
      className={cn(
        'rounded-lg bg-black/10 p-6 dark:bg-white/10',
        'duration-300 animate-in fade-in slide-in-from-bottom-4'
      )}
    >
      <h2 className="mb-4 text-center text-xl font-bold text-black dark:text-white">
        {secret.title}
      </h2>
      
      {/* Media Display */}
      {secret.media && (
        <div className="mb-4 flex justify-center">
          <SecretMedia media={secret.media} />
        </div>
      )}
      
      {/* Content Text */}
      {secret.content && (
        <p className="text-center text-gray-700 dark:text-gray-300">
          {secret.content}
        </p>
      )}
    </div>
  );
};
```

Now you can add Giphy embeds to your secret codes in three ways:

1. Using just the Giphy ID:
```typescript
{
  code: 'UWU',
  title: 'UwU Mode',
  media: {
    type: 'giphy',
    giphyId: 'GVtvJRr3sJDbkNdumY',
    alt: 'UwU kawaii animation',
  },
  achievementId: 'secret-uwu',
}
```

2. Using a full Giphy URL (we'll extract the ID):
```typescript
{
  code: 'DANCE',
  title: 'Dance Party',
  media: {
    type: 'giphy',
    url: 'https://giphy.com/embed/GVtvJRr3sJDbkNdumY',
    alt: 'Dancing animation',
  },
  achievementId: 'secret-dance',
}
```

3. Or still using regular images/GIFs:
```typescript
{
  code: 'PHOTO',
  title: 'Photo Mode',
  media: {
    type: 'image',
    url: '/images/photo.jpg',
    alt: 'A beautiful photo',
  },
  achievementId: 'secret-photo',
}
```

This implementation:
1. Properly handles Giphy embeds with responsive sizing
2. Maintains support for regular images and GIFs
3. Uses proper aspect ratios for different media types
4. Includes accessibility features (alt text, titles)
5. Separates media rendering logic for better maintainability

The Giphy embeds will be responsive and maintain their aspect ratio while fitting nicely within the secret content container.

---

_**User**_

why do we need the url field?

---

_**Agent**_



You're right - for Giphy embeds, we don't need the URL field since we're only using the Giphy ID. Let's simplify the types to make this clearer:

```typescript:src/blocks/HomeHero/secrets.ts
export type MediaData = {
  type: 'image' | 'gif' | 'giphy';
  alt?: string;
} & (
  | {
      type: 'giphy';
      giphyId: string;
    }
  | {
      type: 'image' | 'gif';
      url: string;
    }
);

export type SecretData = {
  code: string;
  title: string;
  content?: string;
  achievementId?: string;
  media?: MediaData;
};

export const secretCodes: SecretData[] = [
  {
    code: 'UWU',
    title: 'UwU Mode',
    media: {
      type: 'giphy',
      giphyId: 'GVtvJRr3sJDbkNdumY',
      alt: 'UwU kawaii animation',
    },
    achievementId: 'secret-uwu',
  },
  {
    code: 'PHOTO',
    title: 'Photo Mode',
    media: {
      type: 'image',
      url: '/images/photo.jpg',
      alt: 'A beautiful photo',
    },
    achievementId: 'secret-photo',
  },
];
```

This improved type definition:
1. Uses TypeScript discriminated unions to ensure:
   - Giphy media must have a `giphyId`
   - Image/gif media must have a `url`
2. Eliminates the possibility of providing unnecessary fields
3. Provides better type safety and autocompletion
4. Makes the API more intuitive to use

The component code remains the same, but now the types are more precise and self-documenting.

---

_**User**_

alright now how are we rendering this content in the HomeHeroBlock

---

_**Agent**_



Looking at your current HomeHeroBlock component, let's update the secret content rendering section. Here's how we should modify it:

```typescript:src/blocks/HomeHero/Component.tsx
const SecretMedia: React.FC<{ media: MediaData }> = ({ media }) => {
  if (media.type === 'giphy') {
    return (
      <div className="relative w-full pt-[56.25%]">
        <iframe
          src={`https://giphy.com/embed/${media.giphyId}`}
          className="absolute inset-0 h-full w-full rounded-lg"
          frameBorder="0"
          allowFullScreen
          title={media.alt || 'Giphy embed'}
        />
      </div>
    );
  }

  return (
    <img
      src={media.url}
      alt={media.alt || 'Secret content media'}
      className={cn(
        'rounded-lg',
        media.type === 'gif' 
          ? 'max-h-[200px] object-contain' 
          : 'max-h-[300px] object-cover'
      )}
      loading="lazy"
    />
  );
};

const SecretContent: React.FC<{ secret: SecretData }> = ({ secret }) => {
  return (
    <div
      className={cn(
        'rounded-lg bg-black/10 p-6 dark:bg-white/10',
        'duration-300 animate-in fade-in slide-in-from-bottom-4'
      )}
    >
      <h2 className="mb-4 text-center text-xl font-bold text-black dark:text-white">
        {secret.title}
      </h2>
      
      {/* Media Display */}
      {secret.media && (
        <div className={cn(
          'mb-4 flex justify-center',
          // Add different width constraints based on media type
          secret.media.type === 'giphy' ? 'max-w-md mx-auto w-full' : ''
        )}>
          <SecretMedia media={secret.media} />
        </div>
      )}
      
      {/* Content Text */}
      {secret.content && (
        <p className="text-center text-gray-700 dark:text-gray-300">
          {secret.content}
        </p>
      )}
    </div>
  );
};

export const HomeHeroBlock: React.FC<HomeHeroProps> = ({
  mainText,
  dynamicText,
  links,
}) => {
  // ... existing state and handlers ...

  return (
    <div className="animate-pull-down container relative z-0 -mt-1 flex h-full flex-col items-center justify-center rounded-b-xl bg-black/5 p-4 pt-8 shadow-lg shadow-black/35 lg:pt-28 dark:bg-white/5">
      {/* ... existing hero content ... */}

      {/* Secret Content Area */}
      <div className="mt-4 w-full max-w-2xl">
        {/* Sequence Display */}
        {puzzleState.sequence && (
          <div
            className={cn(
              'mb-4 flex items-center justify-center gap-2',
              'duration-300 animate-in fade-in slide-in-from-top-4'
            )}
          >
            <span className="text-lg font-medium text-black dark:text-white">
              {puzzleState.sequence}
            </span>
            <button
              onClick={handleClearQuery}
              className={cn(
                'rounded-full p-1 text-sm text-gray-500 hover:text-red-500',
                'transition-colors duration-200'
              )}
              aria-label="Clear code"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <line x1="18" y1="6" x2="6" y2="18" />
                <line x1="6" y1="6" x2="18" y2="18" />
              </svg>
            </button>
          </div>
        )}

        {/* Error Message */}
        {showError && (
          <div
            className={cn(
              'mb-4 text-center text-red-500',
              'duration-300 animate-in fade-in zoom-in'
            )}
          >
            Invalid Code
          </div>
        )}

        {/* Secret Content */}
        {puzzleState.activeSecret && (
          <SecretContent secret={puzzleState.activeSecret} />
        )}
      </div>
    </div>
  );
};
```

Key improvements in this implementation:

1. Separated `SecretMedia` component for cleaner media rendering logic
2. Type-safe media handling based on the `MediaData` discriminated union
3. Responsive layout for different media types:
   - Giphy embeds get a max-width and maintain aspect ratio
   - Images and GIFs have appropriate height constraints
4. Proper animation and transitions for content appearance
5. Maintained all existing functionality while adding media support

The secret content will now display:
1. The secret title
2. Media content (if provided) with appropriate sizing
3. Text content (if provided)

Each media type (giphy, image, gif) will be rendered appropriately with:
- Proper aspect ratios
- Responsive sizing
- Loading optimizations
- Accessibility attributes

---

_**User**_

you should be using Next/Image

---

_**Agent**_



You're absolutely right! Let's update the SecretMedia component to use Next.js Image component for better performance and optimization:

```typescript:src/blocks/HomeHero/Component.tsx
import Image from 'next/image';

const SecretMedia: React.FC<{ media: MediaData }> = ({ media }) => {
  if (media.type === 'giphy') {
    return (
      <div className="relative w-full pt-[56.25%]">
        <iframe
          src={`https://giphy.com/embed/${media.giphyId}`}
          className="absolute inset-0 h-full w-full rounded-lg"
          frameBorder="0"
          allowFullScreen
          title={media.alt || 'Giphy embed'}
        />
      </div>
    );
  }

  return (
    <div className={cn(
      'relative',
      media.type === 'gif' 
        ? 'h-[200px] w-[300px]' // Fixed dimensions for GIFs
        : 'h-[300px] w-[500px]'  // Fixed dimensions for images
    )}>
      <Image
        src={media.url}
        alt={media.alt || 'Secret content media'}
        fill
        className={cn(
          'rounded-lg',
          media.type === 'gif' 
            ? 'object-contain' 
            : 'object-cover'
        )}
        sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
        priority={media.type === 'gif'} // Load GIFs immediately
      />
    </div>
  );
};

const SecretContent: React.FC<{ secret: SecretData }> = ({ secret }) => {
  return (
    <div
      className={cn(
        'rounded-lg bg-black/10 p-6 dark:bg-white/10',
        'duration-300 animate-in fade-in slide-in-from-bottom-4'
      )}
    >
      <h2 className="mb-4 text-center text-xl font-bold text-black dark:text-white">
        {secret.title}
      </h2>
      
      {/* Media Display */}
      {secret.media && (
        <div className={cn(
          'mb-4 flex justify-center',
          secret.media.type === 'giphy' ? 'mx-auto w-full max-w-md' : ''
        )}>
          <SecretMedia media={secret.media} />
        </div>
      )}
      
      {/* Content Text */}
      {secret.content && (
        <p className="text-center text-gray-700 dark:text-gray-300">
          {secret.content}
        </p>
      )}
    </div>
  );
};
```

Key improvements:
1. Uses Next.js Image component for:
   - Automatic image optimization
   - Lazy loading
   - Blur placeholder support
   - Responsive image sizing
2. Fixed dimensions for the image container to prevent layout shift
3. Different handling for GIFs vs static images:
   - GIFs use `priority` to load immediately
   - Static images use lazy loading
4. Proper `sizes` attribute for responsive images
5. Maintained aspect ratio handling for Giphy embeds

You'll also need to add the domains or paths to your Next.js config for the images:

```typescript:next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: [
      // Add your image domains here
      'your-image-domain.com',
    ],
  },
};

module.exports = nextConfig;
```

Now your images will be:
1. Automatically optimized
2. Properly sized for different devices
3. Lazy loaded when appropriate
4. Served in modern formats (WebP/AVIF)
5. Protected against layout shift

---

_**User**_

I want to refactor this section where the setExpandedText function is.

I want to have multiple strings that can be used as expanded text and have the function choose a random one each time the code is submitted

---

_**Agent**_

I'll help you modify the code to handle multiple expanded text options with random selection:

```typescript:src/blocks/HomeHero/Component.tsx
// Add this constant at the top of the file or in a separate constants file
const EXPANDED_TEXT_OPTIONS = [
  ' Quick examples include fixing bugs, jumping hurdles, or crafting zesty, unique experiences.',
  ' Explore various quirks, jumping foxes, and blazing through complex development zones.',
  ' Quest journals bring exciting adventures, while fixing complex puzzles daily.',
  ' Quickly jumping developers fix buzzing virtual machines with expert precision.',
] as const;

// ... existing imports and code ...

const handleCharacterClick = (char: string) => {
  setShowError(false);

  if (char === '?') {
    if (!puzzleState.sequence) return;

    const matchingSecret = secretCodes.find(
      (code) => code.code.toLowerCase() === puzzleState.sequence.toLowerCase()
    );

    if (matchingSecret) {
      // Handle the MORELETTERS code with random text selection
      if (puzzleState.sequence.toLowerCase() === 'moreletters') {
        const randomIndex = Math.floor(Math.random() * EXPANDED_TEXT_OPTIONS.length);
        setExpandedText(EXPANDED_TEXT_OPTIONS[randomIndex]);
      }

      if (matchingSecret.achievementId) {
        useAchievementStore
          .getState()
          .unlockAchievement(matchingSecret.achievementId);
      }

      setPuzzleState((prev) => ({
        ...prev,
        isSubmitted: true,
        activeSecret: matchingSecret,
      }));
    } else {
      setShowError(true);
      setTimeout(() => {
        setPuzzleState({
          sequence: '',
          isSubmitted: false,
          activeSecret: null,
        });
        setShowError(false);
      }, 2000);
    }
    return;
  }

  // ... rest of the function
};
```

Key improvements:
1. Created a constant array of text options
2. Each option includes different letters to expand the available character set
3. Uses random selection for variety
4. Each string is crafted to include uncommon letters (q, j, z, x, etc.)
5. Maintains pangram-like qualities (containing many different letters)

You could also move the text options to a separate file for better organization:

```typescript:src/blocks/HomeHero/constants.ts
export const EXPANDED_TEXT_OPTIONS = [
  ' Quick examples include fixing bugs, jumping hurdles, or crafting zesty, unique experiences.',
  ' Explore various quirks, jumping foxes, and blazing through complex development zones.',
  ' Quest journals bring exciting adventures, while fixing complex puzzles daily.',
  ' Quickly jumping developers fix buzzing virtual machines with expert precision.',
] as const;
```

Then import and use it in your component:

```typescript:src/blocks/HomeHero/Component.tsx
import { EXPANDED_TEXT_OPTIONS } from './constants';

// ... rest of the component code
```

This makes the code more maintainable and easier to add new text options in the future.

---

_**User**_

can we make sure that it always chooses a different option for every submit and does not repeat

---

_**Agent**_



Here's how we can modify the code to ensure we cycle through all options without repetition:

```typescript:src/blocks/HomeHero/expandedText.ts
export const EXPANDED_TEXT_OPTIONS = [
  ' Quick examples include fixing bugs, jumping hurdles, or crafting zesty, unique experiences.',
  ' Explore various quirks, jumping foxes, and blazing through complex development zones.',
  ' Quest journals bring exciting adventures, while fixing complex puzzles daily.',
  ' Quickly jumping developers fix buzzing virtual machines with expert precision.',
] as const;
```

```typescript:src/blocks/HomeHero/Component.tsx
// ... existing imports ...

export const HomeHeroBlock: React.FC<HomeHeroProps> = ({
  mainText,
  dynamicText,
  links,
}) => {
  // ... other state ...
  const [expandedText, setExpandedText] = useState('');
  const [usedTextIndices, setUsedTextIndices] = useState<Set<number>>(new Set());

  const getNextExpandedText = () => {
    // If we've used all options, reset the used indices
    if (usedTextIndices.size >= EXPANDED_TEXT_OPTIONS.length) {
      setUsedTextIndices(new Set());
    }

    // Get available indices that haven't been used
    const availableIndices = Array.from(
      { length: EXPANDED_TEXT_OPTIONS.length },
      (_, i) => i
    ).filter(index => !usedTextIndices.has(index));

    // Choose random index from available options
    const randomIndex = Math.floor(Math.random() * availableIndices.length);
    const selectedIndex = availableIndices[randomIndex];

    // Update used indices
    setUsedTextIndices(prev => new Set([...prev, selectedIndex]));

    return EXPANDED_TEXT_OPTIONS[selectedIndex];
  };

  const handleCharacterClick = (char: string) => {
    setShowError(false);

    if (char === '?') {
      if (!puzzleState.sequence) return;

      const matchingSecret = secretCodes.find(
        (code) => code.code.toLowerCase() === puzzleState.sequence.toLowerCase()
      );

      if (matchingSecret) {
        if (puzzleState.sequence.toLowerCase() === 'moreletters') {
          setExpandedText(getNextExpandedText());
        }

        if (matchingSecret.achievementId) {
          useAchievementStore
            .getState()
            .unlockAchievement(matchingSecret.achievementId);
        }

        setPuzzleState((prev) => ({
          ...prev,
          isSubmitted: true,
          activeSecret: matchingSecret,
        }));
      } else {
        setShowError(true);
        setTimeout(() => {
          setPuzzleState({
            sequence: '',
            isSubmitted: false,
            activeSecret: null,
          });
          setShowError(false);
        }, 2000);
      }
      return;
    }

    // ... rest of the function
  };

  // ... rest of the component
};
```

This implementation:
1. Keeps track of which text options have been used with a Set
2. Ensures each option is used before repeating any
3. Automatically resets when all options have been used
4. Maintains randomness within the unused options
5. Provides a clean way to cycle through all available texts

The flow works like this:
1. First submission: Randomly selects from all 4 options
2. Second submission: Randomly selects from remaining 3 options
3. Third submission: Randomly selects from remaining 2 options
4. Fourth submission: Uses the last unused option
5. Fifth submission: Resets and starts over with all options available again

This ensures variety while preventing immediate repetition of the same text.

---

