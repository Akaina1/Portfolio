<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session e6d9b3ed-af8c-4bd1-8579-abbd2866da31 (2025-03-04 00:41Z) -->

# Untitled (2025-03-04 00:41Z)

_**User (2025-03-04 00:43Z)**_

I have this page set as my map creator for my ascii art maps.

currently I can select a terrain object and place it onto the grid individually.

I would like to add logic so I can do the following:

1. create a straight line of a terrain selection
2. create an empty square and fill in a square area with a terrain selection
3. create an empty circle and fill in a circle (of tiles) with a terrain selection

How can we do this here

---

_**Agent**_

# Adding Drawing Tools to the Map Creator

I'll implement the requested drawing tools for your ASCII map creator. We'll need to add:

1. Line drawing tool
2. Rectangle drawing (outline and fill)
3. Circle drawing (outline and fill)

Here's how we can implement these features:

```tsx:src/app/(frontend)/map-creator/page.tsx
// ... existing code ...

export default function MapCreator() {
  // ... existing state ...

  // State for the currently selected drawing tool
  const [drawingTool, setDrawingTool] = useState<'single' | 'line' | 'rectangle' | 'rectangle-fill' | 'circle' | 'circle-fill'>('single');
  
  // State for tracking drawing operations
  const [isDrawing, setIsDrawing] = useState(false);
  const [startPoint, setStartPoint] = useState<{x: number, y: number} | null>(null);
  const [endPoint, setEndPoint] = useState<{x: number, y: number} | null>(null);
  const [previewMap, setPreviewMap] = useState<string[][] | null>(null);

  // ... existing code ...

  // Draw a line between two points using Bresenham's algorithm
  const drawLine = (x0: number, y0: number, x1: number, y1: number, map: string[][], terrain: string) => {
    const newMap = JSON.parse(JSON.stringify(map));
    
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    
    while (true) {
      if (x0 >= 0 && x0 < mapWidth && y0 >= 0 && y0 < mapHeight) {
        newMap[y0][x0] = terrain;
      }
      
      if (x0 === x1 && y0 === y1) break;
      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y0 += sy;
      }
    }
    
    return newMap;
  };
  
  // Draw a rectangle (outline or filled)
  const drawRectangle = (x0: number, y0: number, x1: number, y1: number, map: string[][], terrain: string, fill: boolean) => {
    const newMap = JSON.parse(JSON.stringify(map));
    
    // Ensure x0,y0 is the top-left and x1,y1 is the bottom-right
    const [startX, endX] = [Math.min(x0, x1), Math.max(x0, x1)];
    const [startY, endY] = [Math.min(y0, y1), Math.max(y0, y1)];
    
    for (let y = startY; y <= endY; y++) {
      for (let x = startX; x <= endX; x++) {
        // For outline, only draw if on the perimeter
        if (fill || y === startY || y === endY || x === startX || x === endX) {
          if (x >= 0 && x < mapWidth && y >= 0 && y < mapHeight) {
            newMap[y][x] = terrain;
          }
        }
      }
    }
    
    return newMap;
  };
  
  // Draw a circle (outline or filled)
  const drawCircle = (centerX: number, centerY: number, radius: number, map: string[][], terrain: string, fill: boolean) => {
    const newMap = JSON.parse(JSON.stringify(map));
    
    // Calculate radius based on the distance between start and end points
    for (let y = 0; y < mapHeight; y++) {
      for (let x = 0; x < mapWidth; x++) {
        // Calculate distance from center
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
        
        // For outline, only draw if approximately on the circle edge
        // For fill, draw if inside the circle
        if ((fill && distance <= radius) || (!fill && Math.abs(distance - radius) < 0.5)) {
          newMap[y][x] = terrain;
        }
      }
    }
    
    return newMap;
  };

  // Handle mouse down to start drawing
  const handleMouseDown = (rowIndex: number, colIndex: number) => {
    if (drawingTool === 'single') {
      // For single cell placement, just update directly
      handleCellClick(rowIndex, colIndex);
      return;
    }
    
    setIsDrawing(true);
    setStartPoint({ x: colIndex, y: rowIndex });
    setEndPoint({ x: colIndex, y: rowIndex });
    
    // Show preview for initial point
    const preview = JSON.parse(JSON.stringify(mapData));
    preview[rowIndex][colIndex] = selectedTerrain;
    setPreviewMap(preview);
  };
  
  // Handle mouse move during drawing
  const handleMouseMove = (rowIndex: number, colIndex: number) => {
    if (!isDrawing || !startPoint) return;
    
    setEndPoint({ x: colIndex, y: rowIndex });
    
    // Create a preview based on the current tool
    let preview = JSON.parse(JSON.stringify(mapData));
    
    switch (drawingTool) {
      case 'line':
        preview = drawLine(startPoint.x, startPoint.y, colIndex, rowIndex, preview, selectedTerrain);
        break;
      case 'rectangle':
        preview = drawRectangle(startPoint.x, startPoint.y, colIndex, rowIndex, preview, selectedTerrain, false);
        break;
      case 'rectangle-fill':
        preview = drawRectangle(startPoint.x, startPoint.y, colIndex, rowIndex, preview, selectedTerrain, true);
        break;
      case 'circle':
      case 'circle-fill': {
        const centerX = (startPoint.x + colIndex) / 2;
        const centerY = (startPoint.y + rowIndex) / 2;
        const radius = Math.sqrt(
          Math.pow(colIndex - startPoint.x, 2) + Math.pow(rowIndex - startPoint.y, 2)
        ) / 2;
        preview = drawCircle(centerX, centerY, radius, preview, selectedTerrain, drawingTool === 'circle-fill');
        break;
      }
    }
    
    setPreviewMap(preview);
  };
  
  // Handle mouse up to complete drawing
  const handleMouseUp = () => {
    if (!isDrawing || !startPoint || !endPoint || !previewMap) return;
    
    // Save current state to history before making changes
    saveToHistory(mapData);
    
    // Apply the preview to the actual map
    setMapData(previewMap);
    
    // Reset drawing state
    setIsDrawing(false);
    setStartPoint(null);
    setEndPoint(null);
    setPreviewMap(null);
  };

  // ... existing code ...

  return (
    <div className="min-h-screen w-full p-24">
      <h1 className="mb-4 text-3xl font-bold">ASCII Map Creator</h1>

      {/* Map Configuration */}
      {/* ... existing code ... */}

      {/* Drawing Tools */}
      <div className="mb-6 rounded-lg border border-gray-700 bg-gray-800 p-4">
        <h2 className="mb-2 text-xl font-semibold">Drawing Tools</h2>
        <div className="flex flex-wrap gap-2">
          <button
            onClick={() => setDrawingTool('single')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'single' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Single Tile
          </button>
          <button
            onClick={() => setDrawingTool('line')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'line' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Line
          </button>
          <button
            onClick={() => setDrawingTool('rectangle')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'rectangle' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Rectangle (Outline)
          </button>
          <button
            onClick={() => setDrawingTool('rectangle-fill')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'rectangle-fill' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Rectangle (Fill)
          </button>
          <button
            onClick={() => setDrawingTool('circle')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'circle' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Circle (Outline)
          </button>
          <button
            onClick={() => setDrawingTool('circle-fill')}
            className={`rounded px-3 py-1 ${
              drawingTool === 'circle-fill' 
                ? 'bg-blue-600 text-white' 
                : 'bg-gray-700 text-gray-200 hover:bg-gray-600'
            }`}
          >
            Circle (Fill)
          </button>
        </div>
      </div>

      {/* Terrain Selection */}
      {/* ... existing code ... */}

      {/* Map Editor */}
      <div className="mb-6 rounded-lg border border-gray-700 bg-gray-800 p-4">
        <h2 className="mb-2 text-xl font-semibold">Map Editor</h2>
        <p className="mb-4 text-sm text-gray-400">
          {drawingTool === 'single' 
            ? 'Click on cells to place the selected terrain type.' 
            : 'Click and drag to draw with the selected tool.'}
        </p>

        <div className="overflow-auto">
          <div className="inline-block border-2 border-gray-600">
            {(previewMap || mapData).map((row, rowIndex) => (
              <div key={rowIndex} className="flex">
                {row.map((cell, colIndex) => {
                  const terrain = terrainSymbols[cell];
                  return (
                    <button
                      key={`${rowIndex}-${colIndex}`}
                      className={`flex h-8 w-8 items-center justify-center border border-gray-800 ${
                        terrain.color
                      } hover:bg-gray-700`}
                      onMouseDown={() => handleMouseDown(rowIndex, colIndex)}
                      onMouseMove={() => handleMouseMove(rowIndex, colIndex)}
                      onMouseUp={handleMouseUp}
                      onMouseLeave={() => {
                        // Optional: handle mouse leaving the cell during drawing
                        if (isDrawing) {
                          handleMouseMove(rowIndex, colIndex);
                        }
                      }}
                      title={`${terrain.name} (${rowIndex}, ${colIndex})`}
                    >
                      {terrain.symbol}
                    </button>
                  );
                })}
              </div>
            ))}
          </div>
        </div>

        <div className="mt-4">
          <p className="text-sm">
            Selected:
            <span
              className={`ml-2 font-mono ${terrainSymbols[selectedTerrain].color}`}
            >
              {terrainSymbols[selectedTerrain].symbol}
            </span>
            <span className="ml-1">
              ({terrainSymbols[selectedTerrain].name})
            </span>
          </p>
        </div>
      </div>

      {/* Map Preview */}
      {/* ... existing code ... */}
    </div>
  );
}
```

## Explanation of Changes

I've added several new features to your map creator:

1. **Drawing Tools Section**
   - Added a new UI section with buttons to select different drawing tools
   - Tools include: single tile, line, rectangle (outline), rectangle (fill), circle (outline), and circle (fill)

2. **Drawing State Management**
   - Added state variables to track the drawing process: `isDrawing`, `startPoint`, `endPoint`, and `previewMap`
   - The `previewMap` shows a real-time preview of what's being drawn

3. **Drawing Algorithms**
   - `drawLine`: Implements Bresenham's line algorithm for drawing straight lines
   - `drawRectangle`: Draws rectangle outlines or filled rectangles
   - `drawCircle`: Draws circle outlines or filled circles

4. **Mouse Event Handlers**
   - `handleMouseDown`: Starts the drawing process
   - `handleMouseMove`: Updates the preview as the user drags
   - `handleMouseUp`: Finalizes the drawing and saves it to history

5. **UI Updates**
   - Updated instructions based on the selected tool
   - Added visual feedback for the selected drawing tool

This implementation allows users to click and drag to create lines, rectangles, and circles with the selected terrain type. The preview updates in real-time as they drag, and the final result is committed to the map when they release the mouse button.

---

